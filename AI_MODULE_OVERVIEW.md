# AI‑модуль PharmaTurk: обзор, как работает, плюсы и минусы

## Что это и зачем

Модуль автоматизирует контент для товаров из парсеров/скраперов: **описания**, **категории** и **анализ изображений**. Вместо ручного заполнения карточек — один запуск (вручную или по событию), после чего результат можно проверить в админке и применить к товару.

---

## Как это устроено (схема)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  Триггер: новый товар от парсера ИЛИ ручной вызов (API / benchmark / админка) │
└─────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ContentGenerator.process_product()                                          │
│  1. Загрузка изображений (R2) → Vision API (анализ картинок)                  │
│  2. RAG: Qdrant — похожие категории + релевантные шаблоны описаний             │
│  3. LLM (OpenAI): промпт = товар + анализ картинок + RAG-контекст            │
│  4. Парсинг ответа → категория, описание, confidence                          │
│  5. Лог в AIProcessingLog; при низкой уверенности — в очередь модерации      │
│  6. По желанию: auto_apply — записать в товар                                 │
└─────────────────────────────────────────────────────────────────────────────┘
                                        │
          ┌─────────────────────────────┼─────────────────────────────┐
          ▼                             ▼                             ▼
   AIProcessingLog              AIModerationQueue              Product (если auto_apply)
   (админка: одобрить/           (админка: назначить,            (категория, описание
    отклонить/перезапустить)      разрешить)                      обновлены)
```

**Компоненты:**

| Компонент | Роль |
|-----------|------|
| **LLM (OpenAI)** | Генерация текста (описание, категория), эмбеддинги, анализ изображений (Vision). |
| **Qdrant** | Векторная БД: категории и шаблоны описаний как векторы. RAG — «подсказки» для LLM по названию/описанию товара. |
| **R2** | Загрузка картинок товара для Vision API (если URL внешние). |
| **Celery (очередь `ai`)** | Фоновый запуск обработки, чтобы не блокировать API/скрапер. |
| **AIProcessingLog** | История по каждому запуску: входные данные, ответ LLM, стоимость, статус, действие «применить». |

---

## Чем это помогает проекту

1. **Меньше ручной работы** — для товаров с парсеров описание и категория предлагаются автоматически.
2. **Единый стиль** — RAG подставляет примеры категорий и шаблоны описаний из вашей базы, модель опирается на них.
3. **Контроль качества** — всё пишется в лог; низкая уверенность уходит в очередь модерации; применение к товару — только после одобрения (или с `auto_apply` на свой риск).
4. **Прозрачность** — в логах видно стоимость (OpenAI), время, исходный ответ модели.
5. **Масштаб** — можно гонять пачками (batch) и по расписанию (Celery Beat): неописанные, без категории, повтор неудачных.

---

## Как пользоваться

### Разово: подготовка RAG

```bash
docker compose exec backend poetry run python manage.py setup_ai_rag
```

Создаёт коллекции в Qdrant и заполняет их категориями и шаблонами из БД (эмбеддинги через OpenAI). Нужен `OPENAI_API_KEY` в `.env`.

### Ручной прогон по N товарам (без очереди)

```bash
# только показать список товаров
docker compose exec backend poetry run python manage.py benchmark_ai 5 --dry-run

# реальная обработка, без записи в товар
docker compose exec backend poetry run python manage.py benchmark_ai 3

# с записью результата в товар
docker compose exec backend poetry run python manage.py benchmark_ai 2 --auto-apply
```

Итог в консоли: успех/ошибки, стоимость, средняя уверенность. Подробности — в **Админка → AI → Логи AI обработки**.

### Через API (задача в очередь Celery)

Нужна авторизация: **JWT** или сессия админки (см. ниже «Что такое JWT»).

```bash
# Запуск обработки товара с ID=123
curl -X POST http://localhost:8000/api/ai/process/123/ \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_JWT" \
  -d '{"generate_description": true, "categorize": true, "analyze_images": true, "auto_apply": false}'
```

Задача уходит в очередь `ai`. Её выполняет воркер **celery_ai** (`docker compose ps celery_ai`).

### Автоматически при появлении товара

Если товар создаётся с `external_data.source` / `scraped_sources` / `supplier` (т.е. «от парсера»), срабатывает сигнал и в очередь кладётся задача `process_product_ai_task` с `auto_apply=False`. Результат только в логах — применение через админку или повторный вызов с `auto_apply=True`.

### Админка Django

- **AI → Логи AI обработки** — просмотр, фильтр по статусу/товару, действия: **Применить результат к товару**, Перезапустить AI, Одобрить, Отклонить.
- **AI → AI шаблоны** — шаблоны для RAG и промптов; можно привязать к категории (подробно в **AI_TEMPLATES.md**).
- **AI → Очередь на модерацию** — назначение ответственного и разрешение записей. Шаги и типичные проблемы — в **AI_QUICK_TEST.md**.

---

## Что такое JWT и зачем он нужен

**JWT** (JSON Web Token) — это короткая строка-«пропуск», которую сервер выдаёт после логина (логин + пароль). Дальше при каждом запросе к защищённым эндпоинтам ты передаёшь этот пропуск в заголовке `Authorization: Bearer <токен>`. Сервер по токену понимает, *кто* ты, и разрешает или запрещает доступ.

**Зачем в проекте:** эндпоинты `/api/ai/process/...`, `/api/ai/stats/` и т.д. доступны только авторизованным пользователям. Без токена (или без сессии админки) будет 401.

**Как получить JWT:**

```bash
# Подставь свои логин и пароль (например, суперпользователя Django)
curl -X POST http://localhost:8000/api/auth/jwt/create/ \
  -H "Content-Type: application/json" \
  -d '{"username": "admin", "password": "твой_пароль"}'
```

В ответ придёт `access` — это и есть токен для заголовка `Authorization: Bearer <access>`. Им можно вызывать AI API. Альтернатива: зайти в админку в браузере (логин/пароль) — тогда запросы из этого браузера к API могут идти с сессией (cookie), без JWT.

**Итого:** JWT = способ «предъявить личность» при вызове API; для ручных тестов AI достаточно один раз получить токен и подставлять его в `curl` или в настройках клиента.

---

## Парсер (ummaland и др.) и AI: не двойной расход

**Парсер ummaland не вызывает OpenAI/LLM.** Он только **скрапит** страницы: название, описание, цену, картинки, а также **уже готовые** meta-теги с сайта (title, description, keywords) — то есть то, что на сайте umma-land.com уже есть в HTML. Это не генерация текста, токены на это не тратятся.

**Кто тратит токены:** только центральный модуль AI — задача `process_product_ai_task` → `ContentGenerator` → LLM (описание, категория, анализ картинок, эмбеддинги для RAG). Парсер лишь создаёт/обновляет товар в БД; после этого может запуститься одна задача AI на товар.

**Было дублирование:** при создании нового товара скрапером задача AI ставилась **дважды** — из сигнала `post_save` (создан товар «от парсера») и из кода скрапера `_create_new_product`. Один и тот же товар обрабатывался два раза = двойной расход токенов. Это исправлено: для новых товаров задачу ставит **только сигнал** (один раз); вызов из `_create_new_product` убран. Если описание и SEO уже заполнены (например, скрапнуты с сайта), сигнал задачу не ставит.

**Итого:** парсер не использует AI; токены тратит только центральный AI, и на один новый товар теперь уходит одна задача, а не две.

---

## Плюсы

| Плюс | Пояснение |
|------|------------|
| Автоматизация | Описание и категория для парсерных товаров без ручного копирования. |
| RAG | Модель использует ваши категории и шаблоны — ответы ближе к структуре каталога. |
| Модерация | Низкая уверенность не применяется сразу; есть очередь и явное «одобрить/отклонить». |
| Логи и стоимость | По каждому запуску — токены, cost_usd, время; удобно считать бюджет и оптимизировать. |
| Гибкость | Можно включать только описание, только категорию или только анализ картинок; есть batch и расписание. |
| Масштаб | Celery + отдельная очередь `ai` — не нагружает основной воркер. |

---

## Минусы и ограничения

| Минус | Пояснение |
|-------|------------|
| Зависимость от OpenAI | Нужен API‑ключ; траты на токены и эмбеддинги; при недоступности API обработка падает. |
| Инфраструктура | Qdrant, Redis, воркер celery_ai — больше сервисов и настроек. |
| Качество не гарантировано | Модель может ошибаться; без модерации и выборочного применения риск мусора в каталоге. |
| RAG требует поддержки | После смены категорий/шаблонов нужно заново запускать `setup_ai_rag`. |
| Язык/тон | Зависит от промптов и примеров; для стабильного стиля нужна настройка и шаблоны. |
| Картинки | Vision и R2 работают только если у товара есть доступные URL изображений. |

---

## Кратко

- **Как работает:** товар (и опционально картинки) → RAG (Qdrant) → промпт с контекстом → LLM → разбор ответа → лог и при желании запись в товар/очередь модерации.
- **Чем помогает:** меньше ручной работы, более предсказуемый стиль за счёт RAG, контроль через логи и модерацию, возможность батчей и расписания.
- **Как пользоваться:** один раз `setup_ai_rag`, дальше — benchmark для тестов, API для поштучного/интеграционного запуска, админка для просмотра и одобрения; автоматика — для новых товаров от парсера.
- **Плюсы:** автоматизация, RAG, модерация, прозрачность затрат, гибкость и масштаб.
- **Минусы:** зависимость от OpenAI и доп. сервисов, необходимость проверки качества и поддержки RAG (категории/шаблоны).
